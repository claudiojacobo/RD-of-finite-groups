

# This file was *autogenerated* from the file helper_functions.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5); _sage_const_9 = Integer(9); _sage_const_6 = Integer(6); _sage_const_21 = Integer(21); _sage_const_7 = Integer(7); _sage_const_109 = Integer(109); _sage_const_8 = Integer(8); _sage_const_325 = Integer(325); _sage_const_1681 = Integer(1681); _sage_const_10 = Integer(10); _sage_const_15121 = Integer(15121); _sage_const_11 = Integer(11); _sage_const_151201 = Integer(151201); _sage_const_12 = Integer(12); _sage_const_1663201 = Integer(1663201); _sage_const_13 = Integer(13); _sage_const_5250198 = Integer(5250198); _sage_const_14 = Integer(14); _sage_const_51891840 = Integer(51891840); _sage_const_15 = Integer(15); _sage_const_726485761 = Integer(726485761); _sage_const_16 = Integer(16); _sage_const_10897286401 = Integer(10897286401); _sage_const_17 = Integer(17); _sage_const_174356582401 = Integer(174356582401); _sage_const_18 = Integer(18); _sage_const_2964061900801 = Integer(2964061900801); _sage_const_19 = Integer(19); _sage_const_53353114214401 = Integer(53353114214401); _sage_const_20 = Integer(20); _sage_const_1013709170073601 = Integer(1013709170073601); _sage_const_20274183401472001 = Integer(20274183401472001); _sage_const_22 = Integer(22); _sage_const_381918437071508900 = Integer(381918437071508900)
from sage.all import gap
import math
def primes_up_to(k):
    """
    returns an ascending list of all primes up through k
    """
    primes = [_sage_const_2 ]
    for i in range(_sage_const_3 ,k):
        for p in primes:
            if i%p == _sage_const_0 : break
        else:
            primes.append(i)
    return(primes)


def partitions(n, k=_sage_const_1 ):
    """
    returns all partitions of n into pieces at least k big
    """
    result = []
    if k <= n: # changed smallest <= n to k <= n -- not sure if that's right
        result = [(n,)]
    for i in range(n//_sage_const_2 ,k-_sage_const_1 ,-_sage_const_1 ):
        result += [ p + (i,) for p in partitions(n-i,i)]
    return result

def partition_tuple(n):
    """
    returns all partitions of n, where each partition p is encoded as a dictionary:
    p[k] is the multiplicity of k in the partition. For example, if p stands for the 
    partition 4+3+3+2 of 12, we have p[4]=1, p[3]=2, p[2]=1, and p[i]=0 otherwise.
    """
    tuples = []
    for partition in partitions(n):
        counts = { i+_sage_const_1 :_sage_const_0  for i in range(n) }
        for i in partition:
            counts[i] += _sage_const_1 
        tuples.append(counts)
    return tuples

def generator_combinations(generators, degree, limit=None):
    """
    computes all ways to decompose degree into generators (specified as a list, where 
    generators[i] tells us the number of generators in degree i) and returns a list of tuples,
    where each tuple contains elements of the form (i,j) to describe the jth generator of
    degree i as part of the sum. Example usage: generator_combinations([1,3,1],3) returns a
    list of the 13 products of f0, f1, f2, and g (deg(fi) = 1 and deg(g) = 2) of degree 3.
    """
    print(generators, degree)
    # initial function call
    if limit == None: 
        limit = (len(generators),generators[-_sage_const_1 ]-_sage_const_1 )

    # strategy is to inductively strip away i from the target degree
    combinations = []
    for i in range(_sage_const_1 ,len(generators)):
        if degree < i:
            break
        for j in range(int(generators[i])):
            # only allow weakly decreasing combinations to avoid duplicates
            if (i,j) > limit: break

            if degree == i: # base case
                combinations.append(((i,j),))
            else: # inductive step
                for c in generator_combinations(generators[:i+_sage_const_1 ],degree-i,(i,j),):
                    combinations.append(((i,j),) + c)

    return combinations

# [1,1,2,3,4,5,7,8]

def generators_from_molien(molien_terms):

    # initialize generators with first non-zero element in molien terms
    generators = [_sage_const_1 ]
    for e in molien_terms[_sage_const_1 :]:
        generators.append(e)
        if e != _sage_const_0 :
            break
 
    # iteratively compute number of new generators from old
    for i in range(len(generators),len(molien_terms)):
        generators.append(molien_terms[i]-(len(generator_combinations(generators,i))))

    return generators

"""
best known bounds on RD from Heberle-Sutherland 2022
note: Claudio is currently in the process of beating
    some of these bounds, so we might update this
"""
def RD(n):
    G = {_sage_const_1 :_sage_const_2 , _sage_const_2 :_sage_const_3 , _sage_const_3 :_sage_const_4 , _sage_const_4 :_sage_const_5 , _sage_const_5 :_sage_const_9 , _sage_const_6 :_sage_const_21 , _sage_const_7 :_sage_const_109 , _sage_const_8 :_sage_const_325 , _sage_const_9 :_sage_const_1681 ,
        _sage_const_10 :_sage_const_15121 , _sage_const_11 :_sage_const_151201 , _sage_const_12 :_sage_const_1663201 , _sage_const_13 :_sage_const_5250198 , _sage_const_14 :_sage_const_51891840 ,
        _sage_const_15 :_sage_const_726485761 , _sage_const_16 :_sage_const_10897286401 , _sage_const_17 :_sage_const_174356582401 ,
        _sage_const_18 :_sage_const_2964061900801 , _sage_const_19 :_sage_const_53353114214401 ,
        _sage_const_20 :_sage_const_1013709170073601 , _sage_const_21 :_sage_const_20274183401472001 ,
        _sage_const_22 :_sage_const_381918437071508900 }
    for m in range(len(G),_sage_const_0 ,-_sage_const_1 ):
        if n >= G[m]:
            return n-m
    return _sage_const_1 
#def power_map_table(power_maps)
    #power_tbl = np.zeros(len(primes)), len(classes)

def get_PSU_order(n,q):
    """
    :param n: integer
    :param q: prime
    :return: order of PSU(n+1, q)
    """
    n += -_sage_const_1  # correction to make the wikipedia formula work (as it's for the differently labeled )
    k = _sage_const_1 
    for i in range(_sage_const_1 , n+_sage_const_1 ):
        k *= q ** (i + _sage_const_1 ) - ((-_sage_const_1 ) ** (i + _sage_const_1 ))
    return k * (q ** ((_sage_const_1 /_sage_const_2 ) * n * (n+_sage_const_1 ))) * (_sage_const_1 /(math.gcd(n+_sage_const_1 , q+_sage_const_1 )))

    

