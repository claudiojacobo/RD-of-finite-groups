

# This file was *autogenerated* from the file PSU_3_P.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5); _sage_const_7 = Integer(7); _sage_const_8 = Integer(8); _sage_const_6 = Integer(6); _sage_const_50 = Integer(50)
from math import gcd
import statistics
import time

load("group_characters.sage")
class GroupCharactersPSU3(GroupCharacters):
    q = _sage_const_1 
    d = _sage_const_0 
    characteristic = _sage_const_1 
    name = ""
    classes = []
    class_order = {}
    centralizer_order = {}
    group_order = _sage_const_0 
    primes = []
    power_map = {}
    characters = []
    minimal_perm = _sage_const_0 
    tp = _sage_const_0 
    rp = _sage_const_0  
    r = _sage_const_0 
    s = _sage_const_0 
    t = _sage_const_0 

    def __init__(self, prime, exp):

        ### useful constants
        self.q = prime**exp
        self.characteristic = prime
        q = self.q
        p = prime
        self.d = gcd(_sage_const_3 ,q+_sage_const_1 )
        d = self.d
        r = q+_sage_const_1 
        s = q-_sage_const_1 
        t = q**_sage_const_2 -q+_sage_const_1 
        rp = r//d
        tp = t//d
        self.tp = tp
        self.rp = rp
        self.s = s
        self.r = r
        self.t = t
        self.group_order = q**_sage_const_3 *r**_sage_const_2 *s*tp
        self.exp = exp


        ### conjugacy classes, class orders, and centralizer orders
        self.classes = [ "C_1", "C_2" ]
        self.class_order["C_1"] = _sage_const_1 
        self.centralizer_order["C_1"] = q**_sage_const_3 *rp*r*s*t
        self.class_order["C_2"] = p
        self.centralizer_order["C_2"] = q**_sage_const_3 *rp

        for l in range(d):
            c = f"C_3^{l}"
            self.classes.append(c)
            ### These class_orders are conjectured but not certain 
            if prime == _sage_const_2 :
                self.class_order[c] = _sage_const_4 
            else:
                self.class_order[c] = prime
            self.centralizer_order[c] = q**_sage_const_3 *rp

        for k in range(_sage_const_1 ,rp):
            c = f"C_4^{k}"
            self.classes.append(c)
            self.class_order[c] = rp//gcd(rp,k)
            self.centralizer_order[c] = q**_sage_const_2 

        for k in range(_sage_const_1 ,rp):
            c = f"C_5^{k}"
            self.classes.append(c)
            self.class_order[c] = rp*p//gcd(rp*p,k)
            self.centralizer_order[c] = q*rp*r*s

        if d == _sage_const_3 :
            self.classes.append("C_6'")
            self.class_order["C_6'"] = _sage_const_3 
            self.centralizer_order["C_6'"] = r**_sage_const_2 

        for l in range(_sage_const_2 ,rp+_sage_const_1 ):
            for k in range(_sage_const_1 ,l):
                m = (-k-l)%r
                if m == _sage_const_0 :
                    m = r
                if l < m:
                    
                    c = f"C_6^{{{k},{l},{m}}}"
                    self.classes.append(c)
                    self.centralizer_order[c] = rp*r
                    """
                    # there is definitely a better way to do this (Pablo's formula?)
                    # (and we need to know it) but this works for now
                    n = 1
                    while True: # heheheh
                        n += 1
                        cn = self.power_of(c,n)
                        if cn[2] == "4":
                            self.class_order[c] = n*self.class_order[cn]
                            break
                        if cn[2] == "1":
                            self.class_order[c] = n
                            break
                    """
                    # This was taking a while so I've replaced it with a maybe incorrect formula
                    self.class_order[c] = int(r / gcd(k,l,m,r))
                    

        for k in range(_sage_const_1 ,rp*s):
            if k*s == _sage_const_0 :
                continue
            c = f"C_7^{k}" 
            self.classes.append(c)
            self.class_order[c] = rp*s // gcd(k, rp*s)
            self.centralizer_order[c] = rp*s

        for k in range(_sage_const_1 ,tp):
            if k*s == _sage_const_0 :
                continue
            c = f"C_8^{k}"
            self.classes.append(c)
            self.class_order[c] = tp
            self.centralizer_order[c] = tp


        ### compute relevant primes
        # there MUST be a better way to do this
        self.primes = primes_up_to(max(self.class_order.values()))


        ### compute power maps
        # this is NOT a good way to do it, but it'll do (for known powers) for now
        start_pm_time = time.time()
        for g in self.classes:
            self.power_map[g] = {}
            for p in self.primes:
                self.power_map[g][p] = self.power_of(g,p)
        print(f"Power Map took {time.time() - start_pm_time}")
        ### implement characters of degree qs and t
        # Generates character table data for Chi_qs and Chi_t^(u)
        start_char_time = time.time()
        UCF = UniversalCyclotomicField() 
        eps = UCF.gen(r) # epsilon as an rth root of unity
        self.characters = [{}]
        for j in range(rp):
            self.characters.append({})
        for g in self.classes:
            i = int(g[_sage_const_2 ]) 
            k,l,m = _sage_const_0 ,_sage_const_0 ,_sage_const_0  
            if i in [_sage_const_3 ,_sage_const_4 ,_sage_const_5 ,_sage_const_7 ,_sage_const_8 ]:
                k = int(g[_sage_const_4 :])
            elif i == _sage_const_6 :
                k,l,m = map(int,g[_sage_const_5 :-_sage_const_1 ].split(','))
            if i == _sage_const_1 : 
                self.characters[_sage_const_0 ][g] = q * s 
            elif i == _sage_const_2 : 
                self.characters[_sage_const_0 ][g] = -q
            elif i == _sage_const_3 : 
                self.characters[_sage_const_0 ][g] = _sage_const_0  
            elif i == _sage_const_4 : 
                self.characters[_sage_const_0 ][g] = -s
            elif i == _sage_const_5 : 
                self.characters[_sage_const_0 ][g] = _sage_const_1  
            elif i == _sage_const_6 : 
                self.characters[_sage_const_0 ][g] = _sage_const_2 
            elif i == _sage_const_7 : 
                self.characters[_sage_const_0 ][g] = _sage_const_0 
            elif i == _sage_const_8 : 
                self.characters[_sage_const_0 ][g] = -_sage_const_1 

            for u in range(_sage_const_1 ,rp):
                if i == _sage_const_1 : 
                    self.characters[u][g] = t 
                elif i == _sage_const_2 : 
                    self.characters[u][g] = -s 
                elif i == _sage_const_3 : 
                    self.characters[u][g] = _sage_const_1 
                elif i == _sage_const_4 : 
                    self.characters[u][g] = -s * eps**(_sage_const_3  * u * k) + eps**(-_sage_const_6  * u * k)  
                elif i == _sage_const_5 : 
                    self.characters[u][g] = eps**(_sage_const_3  * u * k) + eps**(-_sage_const_6  * u * k) 
                elif i == _sage_const_6  : 
                    if g[-_sage_const_1 ] == "'": 
                        self.characters[u][g] = _sage_const_3 
                    else: 
                        self.characters[u][g] = eps**(_sage_const_3  * u * k) + eps**(_sage_const_3  * u * l) + eps**(_sage_const_3  * u * m) 
                elif i == _sage_const_7 : 
                    self.characters[u][g] = eps**(_sage_const_3  * u * k) 
                elif i == _sage_const_8 : 
                    self.characters[u][g] = _sage_const_0  
        print(f"Characters took {time.time() - start_char_time}")
            # return self.characters #end of check for our 2 chars 


        if self.q == _sage_const_5 :
            self.minimal_perm = _sage_const_50 
        else:
            self.minimal_perm = self.q ** _sage_const_3  + _sage_const_1   

    def power_of(self, g, n):
        """
        computes the conjugacy class of g^n
        """
        q = self.q
        d = self.d
        s = q - _sage_const_1 
        r = (q + _sage_const_1 ) // d
        tp = self.tp
        p = self.characteristic
        i = int(g[_sage_const_2 ])

        # initialize
        k,l,m = _sage_const_0 ,_sage_const_0 ,_sage_const_0  

        # string handling to recover indices from string
        # we'll use this when computing characters, but annoying to package as a function
        if i in [_sage_const_3 ,_sage_const_4 ,_sage_const_5 ,_sage_const_7 ,_sage_const_8 ]:
            k = int(g[_sage_const_4 :])
        elif i == _sage_const_6 :
            k,l,m = map(int,g[_sage_const_5 :-_sage_const_1 ].split(','))

        # power map logic
        if i == _sage_const_1 :
            return "C_1"
        elif i == _sage_const_2 :
            if n%p == _sage_const_0 :
                return "C_1"
            return "C_2"
        elif i == _sage_const_3 :
            if self.characteristic == _sage_const_2 :
                if n%_sage_const_4  == _sage_const_0 :
                    return "C_1"
                elif n%_sage_const_2  == _sage_const_2 :
                    return "C_2"
                else:
                    return g 
            else:
                if n%self.characteristic == _sage_const_0 :
                    return "C_1"
                else:
                    return g 
        elif i == _sage_const_4 :
            e = (n*k) % ((q+_sage_const_1 )//d)
            if e == _sage_const_0 :
                return "C_1"
            else:
                return f"C_4^{e}"
        elif i == _sage_const_5 :
            if k*n % ((q+_sage_const_1 )*p//d) == _sage_const_0 :
                return "C_1"
            elif k*n % ((q+_sage_const_1 )//d) == _sage_const_0 :
                return "C_2"
            return f"C_5^{k*n % ((q+_sage_const_1 )//d)}"
        elif i == _sage_const_6 :
            if g[-_sage_const_1 ] == "'":
                if n%_sage_const_3  == _sage_const_0 :
                    return "C_1"
                return "C_6'"
            diag = [(n*x)%((q+_sage_const_1 )//d) for x in (k,l,m)]
            k,l,m = sorted([ (q+_sage_const_1 )//d if x == _sage_const_0  else x for x in diag])
            if k == l or l == m: # broke the rules!
                return self.power_of(f"C_4^1", l)
            return f"C_6^{{{k},{l},{m}}}"
        elif i == _sage_const_7 :
            if k*n % (s*r) == _sage_const_0 :
                return "C_1"
            elif k*n % s == _sage_const_0 :
                return f"C_4^{(statistics.mode([s*k*n % (s*r), k*n % (s*r), (-q*k*n) % (s*r)])// s)}"
            y = k*n % (s*r)
            y = min(y, abs(-q*y))
            return f"C_7^{y}"
        elif i == _sage_const_8 :
            if k*n % tp == _sage_const_0 :
                return "C_1"
            w = k*n % tp
            w = min(w, abs(w*(-q) % tp), abs(w*q*q % tp))
            return f"C_8^{w}"

def primes_up_to(k):
    """
    returns an ascending list of all primes up through k
    """
    primes = [_sage_const_2 ]
    for i in range(_sage_const_3 ,k):
        for p in primes:
            if i%p == _sage_const_0 : break
        else:
            primes.append(i)
    return(primes)

start = time.time()

g = GroupCharactersPSU3(_sage_const_2 , _sage_const_6 )
print(g.power_of("C_7^3",_sage_const_5 ))

end = time.time()

print(f"Elapsed time: {end - start:.4f} seconds")   

