

# This file was *autogenerated* from the file psu_characters.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_3 = Integer(3); _sage_const_5 = Integer(5); _sage_const_50 = Integer(50); _sage_const_4 = Integer(4); _sage_const_2 = Integer(2)
load("helper_functions.sage")
load("group_characters.sage")
class PSU_Characters(GroupCharacters): 
        def __init__(self, n, q):
            # Get schur cover
            if gcd(n,q+_sage_const_1 ) != _sage_const_1 :
                tup = self.get_schur_cover(n,q)
                G = eval(f"libgap.PerfectGroup({tup[_sage_const_0 ]}, {tup[_sage_const_1 ]})")
            else:
                G = eval(f"libgap.PSU({n}, {q})")
            self.name = f"PSU({n},      {q})"
            ct = G.CharacterTable() # We can add a custom generic character table from our lit. rev. if neccessary
            self.classes = libgap.ClassNames(ct).sage()
            r = len(self.classes)

            # parse orders of each conjugacy class representative
            orders = ct.OrdersClassRepresentatives().sage()
            self.class_order = { self.classes[i]:orders[i] for i in range(r)}

            # parse centralizer orders
            centralizers = ct.SizesCentralizers().sage()
            self.centralizer_order = { self.classes[i]:centralizers[i] for i in range(r) }
            self.group_order = centralizers[_sage_const_0 ]
 
            # load necessary power maps
            largest_order = max(orders)
            self.primes = primes_up_to(largest_order)
            self.power_map = { g:{} for g in self.classes }
            for p in self.primes:
                for i in range(len(self.classes)):
                    self.power_map[self.classes[i]][p] = self.classes[ct.PowerMap(p).sage()[i]-_sage_const_1 ]

            # sort characters by degree
            ct = sorted(ct.Irr().sage(), key=lambda x:x[_sage_const_0 ])
            self.characters = [ { self.classes[i]:chi[i] for i in range(r) } for chi in ct]

            # Calculate minimal perm group
            if n == _sage_const_3 : 
                if q == _sage_const_5 :
                    self.minimal_perm = _sage_const_50 
                else:
                    self.minimal_perm = q**_sage_const_3  + _sage_const_1 
            if n == _sage_const_4 :
                self.minimal_perm = (q+_sage_const_1 )(q**_sage_const_3  + _sage_const_1 )
            elif q != _sage_const_2 : # Let's just avoid the q = 2 case for now
                self.minimal_perm = (q**n -(-_sage_const_1 )**n) * (q**(n-_sage_const_1 ) - (-_sage_const_1 )**(n-_sage_const_1 ))/(q**_sage_const_2  - _sage_const_1 ) # from https://arxiv.org/pdf/1301.5166
                
        def get_schur_cover(self, n, q):
            # Initialize GAP through Sage
            gap = Gap()

            # Load packages
            gap.eval('LoadPackage("atlasrep");')
            gap.eval('LoadPackage("perfectgroups");')

            # Define target group - use local variable assignment
            gap.eval(f"G := PSU({n}, {q});")
            gap.eval('target := G;')

            # Set parameters
            size = get_PSU_order(n,q)
            gap.eval(f"size := {size};")
            gap.eval(f'SchurM := {gcd(n, q + _sage_const_1 )} ;')
            gap.eval('N := size * SchurM ;')
            gap.eval('num := NumberPerfectGroups(N);')
            gap.eval('found := false;')
            if gap.eval('num') == "fail":
                raise Exception("size of Schur cover was too large")
            # Search through groups
            for i in range(_sage_const_1 , int(gap.eval('num')) + _sage_const_1 ):
                gap.eval(f'G := PerfectGroup(N, {i});')
                gap.eval('H := Center(G);')
                gap.eval('Q := G/H;')
                if gap.eval('IsomorphismGroups(Q, target) <> fail;') == 'true':
                    return (int(gap.eval("N")), i)
                else:
                    raise Exception("No suitable group found.")

PSU_Characters(_sage_const_4 ,_sage_const_3 )

